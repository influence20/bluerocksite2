{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/src/routes/admin.ts">\nimport express from \'express\';\nimport bcrypt from \'bcryptjs\';\nimport { body, validationResult } from \'express-validator\';\nimport { PrismaClient } from \'@prisma/client\';\nimport { authenticateAdmin, requireRole, AuthRequest } from \'../middleware/auth\';\nimport { asyncHandler, createError } from \'../middleware/errorHandler\';\nimport { calculateInvestmentPlan, generatePayoutSchedule, getNextFriday } from \'../utils/investment\';\nimport { sendEmail } from \'../utils/email\';\nimport { logger } from \'../utils/logger\';\nimport crypto from \'crypto\';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// Admin Dashboard Stats\nrouter.get(\'/dashboard\', authenticateAdmin, asyncHandler(async (req: AuthRequest, res) => {\n  const today = new Date();\n  today.setUTCHours(0, 0, 0, 0);\n\n  const tomorrow = new Date(today);\n  tomorrow.setDate(tomorrow.getDate() + 1);\n\n  const [\n    totalUsers,\n    totalDeposits,\n    totalWithdrawals,\n    pendingDeposits,\n    pendingWithdrawals,\n    activeInvestments,\n    todayStats,\n  ] = await Promise.all([\n    prisma.user.count(),\n    prisma.deposit.aggregate({ _sum: { amount: true }, where: { status: \'CONFIRMED\' } }),\n    prisma.withdrawal.aggregate({ _sum: { amount: true }, where: { status: \'COMPLETED\' } }),\n    prisma.deposit.count({ where: { status: \'PENDING\' } }),\n    prisma.withdrawal.count({ where: { status: { in: [\'PENDING\', \'PIN_REQUIRED\', \'APPROVED\'] } } }),\n    prisma.investmentPlan.count({ where: { status: \'ACTIVE\' } }),\n    Promise.all([\n      prisma.user.count({ where: { createdAt: { gte: today, lt: tomorrow } } }),\n      prisma.deposit.count({ where: { createdAt: { gte: today, lt: tomorrow } } }),\n      prisma.withdrawal.count({ where: { createdAt: { gte: today, lt: tomorrow } } }),\n      prisma.payout.count({ where: { paidDate: { gte: today, lt: tomorrow } } }),\n    ]),\n  ]);\n\n  const [todayUsers, todayDeposits, todayWithdrawals, todayPayouts] = todayStats;\n\n  res.json({\n    success: true,\n    data: {\n      overview: {\n        totalUsers,\n        totalDepositsAmount: totalDeposits._sum.amount || 0,\n        totalWithdrawalsAmount: totalWithdrawals._sum.amount || 0,\n        pendingDeposits,\n        pendingWithdrawals,\n        activeInvestments,\n      },\n      today: {\n        newUsers: todayUsers,\n        newDeposits: todayDeposits,\n        newWithdrawals: todayWithdrawals,\n        processedPayouts: todayPayouts,\n      },\n    },\n  });\n}));\n\n// Get all users\nrouter.get(\'/users\', authenticateAdmin, asyncHandler(async (req: AuthRequest, res) => {\n  const page = parseInt(req.query.page as string) || 1;\n  const limit = parseInt(req.query.limit as string) || 20;\n  const search = req.query.search as string;\n\n  const where: any = {};\n  if (search) {\n    where.OR = [\n      { email: { contains: search, mode: \'insensitive\' } },\n      { firstName: { contains: search, mode: \'insensitive\' } },\n      { lastName: { contains: search, mode: \'insensitive\' } },\n    ];\n  }\n\n  const users = await prisma.user.findMany({\n    where,\n    select: {\n      id: true,\n      email: true,\n      firstName: true,\n      lastName: true,\n      balance: true,\n      totalInvested: true,\n      totalEarnings: true,\n      isActive: true,\n      createdAt: true,\n      lastLoginAt: true,\n    },\n    orderBy: { createdAt: \'desc\' },\n    skip: (page - 1) * limit,\n    take: limit,\n  });\n\n  const total = await prisma.user.count({ where });\n\n  res.json({\n    success: true,\n    data: {\n      users,\n      pagination: {\n        page,\n        limit,\n        total,\n        pages: Math.ceil(total / limit),\n      },\n    },\n  });\n}));\n\n// Get pending deposits\nrouter.get(\'/deposits/pending\', authenticateAdmin, asyncHandler(async (req: AuthRequest, res) => {\n  const deposits = await prisma.deposit.findMany({\n    where: { status: \'PENDING\' },\n    include: {\n      user: {\n        select: {\n          id: true,\n          email: true,\n          firstName: true,\n          lastName: true,\n        },\n      },\n    },\n    orderBy: { createdAt: \'asc\' },\n  });\n\n  res.json({\n    success: true,\n    data: { deposits },\n  });\n}));\n\n// Confirm deposit and create investment plan\nrouter.post(\'/deposits/:id/confirm\', [\n  authenticateAdmin,\n  body(\'transactionId\').optional().trim(),\n], asyncHandler(async (req: AuthRequest, res) => {\n  const depositId = req.params.id;\n  const { transactionId } = req.body;\n  const adminId = req.user!.id;\n\n  const deposit = await prisma.deposit.findUnique({\n    where: { id: depositId },\n    include: { user: true },\n  });\n\n  if (!deposit) {\n    throw createError(\'Deposit not found\', 404);\n  }\n\n  if (deposit.status !== \'PENDING\') {\n    throw createError(\'Deposit already processed\', 400);\n  }\n\n  // Calculate investment plan\n  const investmentCalc = calculateInvestmentPlan(parseFloat(deposit.amount.toString()));\n  const startDate = new Date();\n  const nextPayoutDate = getNextFriday(startDate);\n  const endDate = new Date(nextPayoutDate);\n  endDate.setDate(endDate.getDate() + (7 * 7)); // 8 weeks total\n\n  // Start transaction\n  const result = await prisma.$transaction(async (tx) => {\n    // Update deposit\n    const updatedDeposit = await tx.deposit.update({\n      where: { id: depositId },\n      data: {\n        status: \'CONFIRMED\',\n        confirmedAt: new Date(),\n        confirmedBy: adminId,\n        ...(transactionId && { transactionId }),\n      },\n    });\n\n    // Update user balance and total invested\n    await tx.user.update({\n      where: { id: deposit.userId },\n      data: {\n        totalInvested: {\n          increment: deposit.amount,\n        },\n      },\n    });\n\n    // Create investment plan\n    const investmentPlan = await tx.investmentPlan.create({\n      data: {\n        userId: deposit.userId,\n        depositId: deposit.id,\n        amount: deposit.amount,\n        weeklyPayout: investmentCalc.weeklyPayout,\n        startDate,\n        endDate,\n        nextPayoutDate,\n      },\n    });\n\n    // Generate payout schedule\n    const payoutSchedule = generatePayoutSchedule(startDate, investmentCalc.weeklyPayout);\n    \n    await tx.payout.createMany({\n      data: payoutSchedule.map((payout) => ({\n        investmentPlanId: investmentPlan.id,\n        amount: payout.amount,\n        weekNumber: payout.weekNumber,\n        scheduledDate: payout.scheduledDate,\n      })),\n    });\n\n    // Create transaction record\n    await tx.transaction.create({\n      data: {\n        userId: deposit.userId,\n        type: \'DEPOSIT\',\n        amount: deposit.amount,\n        description: `Investment deposit confirmed - ${deposit.cryptoType}`,\n        reference: `DEP-${deposit.id}`,\n        status: \'COMPLETED\',\n      },\n    });\n\n    return { updatedDeposit, investmentPlan };\n  });\n\n  // Send confirmation email\n  await sendEmail({\n    to: deposit.user.email,\n    template: \'depositConfirmed\',\n    data: {\n      firstName: deposit.user.firstName,\n      amount: deposit.amount.toString(),\n      weeklyPayout: investmentCalc.weeklyPayout.toString(),\n      nextPayoutDate: nextPayoutDate.toLocaleDateString(),\n      totalReturns: investmentCalc.totalReturns.toString(),\n      dashboardUrl: `${process.env.FRONTEND_URL}/dashboard`,\n      logoUrl: `${process.env.FRONTEND_URL}/assets/brand/bluerock-logo.png`,\n    },\n  });\n\n  // Log admin action\n  await prisma.auditLog.create({\n    data: {\n      adminUserId: adminId,\n      action: \'CONFIRM_DEPOSIT\',\n      entity: \'Deposit\',\n      entityId: depositId,\n      newValues: { status: \'CONFIRMED\', amount: deposit.amount },\n      ipAddress: req.ip,\n      userAgent: req.get(\'User-Agent\'),\n    },\n  });\n\n  logger.info(`Deposit confirmed by admin ${req.user!.email}: ${depositId}`);\n\n  res.json({\n    success: true,\n    message: \'Deposit confirmed and investment plan created\',\n    data: result,\n  });\n}));\n\n// Reject deposit\nrouter.post(\'/deposits/:id/reject\', [\n  authenticateAdmin,\n  body(\'reason\').trim().isLength({ min: 10, max: 500 }),\n], asyncHandler(async (req: AuthRequest, res) => {\n  const depositId = req.params.id;\n  const { reason } = req.body;\n  const adminId = req.user!.id;\n\n  const deposit = await prisma.deposit.findUnique({\n    where: { id: depositId },\n    include: { user: true },\n  });\n\n  if (!deposit) {\n    throw createError(\'Deposit not found\', 404);\n  }\n\n  if (deposit.status !== \'PENDING\') {\n    throw createError(\'Deposit already processed\', 400);\n  }\n\n  // Update deposit\n  await prisma.deposit.update({\n    where: { id: depositId },\n    data: {\n      status: \'REJECTED\',\n      notes: reason,\n      confirmedBy: adminId,\n    },\n  });\n\n  // Log admin action\n  await prisma.auditLog.create({\n    data: {\n      adminUserId: adminId,\n      action: \'REJECT_DEPOSIT\',\n      entity: \'Deposit\',\n      entityId: depositId,\n      newValues: { status: \'REJECTED\', reason },\n      ipAddress: req.ip,\n      userAgent: req.get(\'User-Agent\'),\n    },\n  });\n\n  logger.info(`Deposit rejected by admin ${req.user!.email}: ${depositId}`);\n\n  res.json({\n    success: true,\n    message: \'Deposit rejected\',\n  });\n}));\n\n// Get pending withdrawals\nrouter.get(\'/withdrawals/pending\', authenticateAdmin, asyncHandler(async (req: AuthRequest, res) => {\n  const withdrawals = await prisma.withdrawal.findMany({\n    where: { \n      status: { in: [\'PENDING\', \'PIN_REQUIRED\', \'APPROVED\'] },\n    },\n    include: {\n      user: {\n        select: {\n          id: true,\n          email: true,\n          firstName: true,\n          lastName: true,\n          balance: true,\n        },\n      },\n    },\n    orderBy: { createdAt: \'asc\' },\n  });\n\n  res.json({\n    success: true,\n    data: { withdrawals },\n  });\n}));\n\n// Generate withdrawal PIN\nrouter.post(\'/withdrawals/:id/generate-pin\', authenticateAdmin, asyncHandler(async (req: AuthRequest, res) => {\n  const withdrawalId = req.params.id;\n  const adminId = req.user!.id;\n\n  const withdrawal = await prisma.withdrawal.findUnique({\n    where: { id: withdrawalId },\n    include: { user: true },\n  });\n\n  if (!withdrawal) {\n    throw createError(\'Withdrawal not found\', 404);\n  }\n\n  if (withdrawal.status !== \'PENDING\') {\n    throw createError(\'Withdrawal not in pending status\', 400);\n  }\n\n  // Generate 6-digit PIN\n  const pin = crypto.randomInt(100000, 999999).toString();\n  const expiresAt = new Date();\n  expiresAt.setMinutes(expiresAt.getMinutes() + 30); // 30 minutes expiry\n\n  // Create PIN record\n  const withdrawalPin = await prisma.withdrawalPin.create({\n    data: {\n      userId: withdrawal.userId,\n      pin,\n      expiresAt,\n    },\n  });\n\n  // Update withdrawal status\n  await prisma.withdrawal.update({\n    where: { id: withdrawalId },\n    data: { status: \'PIN_REQUIRED\' },\n  });\n\n  // Log admin action\n  await prisma.auditLog.create({\n    data: {\n      adminUserId: adminId,\n      action: \'GENERATE_WITHDRAWAL_PIN\',\n      entity: \'Withdrawal\',\n      entityId: withdrawalId,\n      newValues: { pinId: withdrawalPin.id, expiresAt },\n      ipAddress: req.ip,\n      userAgent: req.get(\'User-Agent\'),\n    },\n  });\n\n  logger.info(`Withdrawal PIN generated by admin ${req.user!.email} for withdrawal ${withdrawalId}`);\n\n  res.json({\n    success: true,\n    message: \'PIN generated successfully\',\n    data: {\n      pin,\n      expiresAt,\n      maskedPin: `${pin.substring(0, 2)}****`,\n    },\n  });\n}));\n\n// Approve withdrawal\nrouter.post(\'/withdrawals/:id/approve\', [\n  authenticateAdmin,\n  body(\'transactionId\').trim().isLength({ min: 10, max: 200 }),\n], asyncHandler(async (req: AuthRequest, res) => {\n  const withdrawalId = req.params.id;\n  const { transactionId } = req.body;\n  const adminId = req.user!.id;\n\n  const withdrawal = await prisma.withdrawal.findUnique({\n    where: { id: withdrawalId },\n    include: { user: true },\n  });\n\n  if (!withdrawal) {\n    throw createError(\'Withdrawal not found\', 404);\n  }\n\n  if (withdrawal.status !== \'APPROVED\') {\n    throw createError(\'Withdrawal not approved by user PIN\', 400);\n  }\n\n  // Process withdrawal\n  const result = await prisma.$transaction(async (tx) => {\n    // Deduct from user balance\n    await tx.user.update({\n      where: { id: withdrawal.userId },\n      data: {\n        balance: {\n          decrement: withdrawal.amount,\n        },\n      },\n    });\n\n    // Update withdrawal\n    const updatedWithdrawal = await tx.withdrawal.update({\n      where: { id: withdrawalId },\n      data: {\n        status: \'COMPLETED\',\n        processedAt: new Date(),\n        processedBy: adminId,\n        transactionId,\n      },\n    });\n\n    // Create transaction record\n    await tx.transaction.create({\n      data: {\n        userId: withdrawal.userId,\n        type: \'WITHDRAWAL\',\n        amount: withdrawal.amount,\n        description: `Withdrawal processed - ${withdrawal.cryptoType}`,\n        reference: `WD-${withdrawal.id}`,\n        status: \'COMPLETED\',\n      },\n    });\n\n    return updatedWithdrawal;\n  });\n\n  // Log admin action\n  await prisma.auditLog.create({\n    data: {\n      adminUserId: adminId,\n      action: \'APPROVE_WITHDRAWAL\',\n      entity: \'Withdrawal\',\n      entityId: withdrawalId,\n      newValues: { status: \'COMPLETED\', transactionId },\n      ipAddress: req.ip,\n      userAgent: req.get(\'User-Agent\'),\n    },\n  });\n\n  logger.info(`Withdrawal approved by admin ${req.user!.email}: ${withdrawalId}`);\n\n  res.json({\n    success: true,\n    message: \'Withdrawal processed successfully\',\n    data: result,\n  });\n}));\n\n// Get audit logs\nrouter.get(\'/audit-logs\', authenticateAdmin, requireRole([\'SUPER_ADMIN\', \'ADMIN\']), asyncHandler(async (req: AuthRequest, res) => {\n  const page = parseInt(req.query.page as string) || 1;\n  const limit = parseInt(req.query.limit as string) || 50;\n  const action = req.query.action as string;\n  const entity = req.query.entity as string;\n\n  const where: any = {};\n  if (action) where.action = action;\n  if (entity) where.entity = entity;\n\n  const logs = await prisma.auditLog.findMany({\n    where,\n    include: {\n      adminUser: {\n        select: {\n          email: true,\n          firstName: true,\n          lastName: true,\n        },\n      },\n    },\n    orderBy: { createdAt: \'desc\' },\n    skip: (page - 1) * limit,\n    take: limit,\n  });\n\n  const total = await prisma.auditLog.count({ where });\n\n  res.json({\n    success: true,\n    data: {\n      logs,\n      pagination: {\n        page,\n        limit,\n        total,\n        pages: Math.ceil(total / limit),\n      },\n    },\n  });\n}));\n\n// Create admin user (Super Admin only)\nrouter.post(\'/users\', [\n  authenticateAdmin,\n  requireRole([\'SUPER_ADMIN\']),\n  body(\'email\').isEmail().normalizeEmail(),\n  body(\'password\').isLength({ min: 8 }),\n  body(\'firstName\').trim().isLength({ min: 2, max: 50 }),\n  body(\'lastName\').trim().isLength({ min: 2, max: 50 }),\n  body(\'role\').isIn([\'SUPER_ADMIN\', \'ADMIN\', \'SUPPORT\']),\n], asyncHandler(async (req: AuthRequest, res) => {\n  const { email, password, firstName, lastName, role } = req.body;\n\n  const existingAdmin = await prisma.adminUser.findUnique({\n    where: { email },\n  });\n\n  if (existingAdmin) {\n    throw createError(\'Admin user already exists with this email\', 409);\n  }\n\n  const hashedPassword = await bcrypt.hash(password, 12);\n\n  const adminUser = await prisma.adminUser.create({\n    data: {\n      email,\n      password: hashedPassword,\n      firstName,\n      lastName,\n      role,\n    },\n    select: {\n      id: true,\n      email: true,\n      firstName: true,\n      lastName: true,\n      role: true,\n      createdAt: true,\n    },\n  });\n\n  // Log admin action\n  await prisma.auditLog.create({\n    data: {\n      adminUserId: req.user!.id,\n      action: \'CREATE_ADMIN_USER\',\n      entity: \'AdminUser\',\n      entityId: adminUser.id,\n      newValues: { email, role },\n      ipAddress: req.ip,\n      userAgent: req.get(\'User-Agent\'),\n    },\n  });\n\n  res.status(201).json({\n    success: true,\n    message: \'Admin user created successfully\',\n    data: { adminUser },\n  });\n}));\n\nexport default router;\n</create-file>\n</function_calls>'}