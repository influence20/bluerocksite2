{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/src/middleware/errorHandler.ts">\nimport { Request, Response, NextFunction } from \'express\';\nimport { logger } from \'../utils/logger\';\n\nexport interface AppError extends Error {\n  statusCode?: number;\n  isOperational?: boolean;\n}\n\nexport const errorHandler = (\n  err: AppError,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  const statusCode = err.statusCode || 500;\n  const message = err.message || \'Internal Server Error\';\n\n  // Log error\n  logger.error({\n    error: err.message,\n    stack: err.stack,\n    url: req.url,\n    method: req.method,\n    ip: req.ip,\n    userAgent: req.get(\'User-Agent\'),\n    statusCode,\n  });\n\n  // Don\'t leak error details in production\n  const isDevelopment = process.env.NODE_ENV === \'development\';\n  \n  res.status(statusCode).json({\n    success: false,\n    error: {\n      message,\n      ...(isDevelopment && { stack: err.stack }),\n    },\n    timestamp: new Date().toISOString(),\n    path: req.url,\n  });\n};\n\nexport const createError = (message: string, statusCode: number = 500): AppError => {\n  const error = new Error(message) as AppError;\n  error.statusCode = statusCode;\n  error.isOperational = true;\n  return error;\n};\n\nexport const asyncHandler = (fn: Function) => (req: Request, res: Response, next: NextFunction) => {\n  Promise.resolve(fn(req, res, next)).catch(next);\n};\n</create-file>\n</function_calls>'}