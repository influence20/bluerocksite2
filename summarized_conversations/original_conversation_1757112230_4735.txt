{'role': 'assistant', 'content': 'Now let me create the authentication routes and user management:\n\n<function_calls>\n<create-file file_path="backend/src/routes/auth.ts">\nimport express from \'express\';\nimport bcrypt from \'bcryptjs\';\nimport jwt from \'jsonwebtoken\';\nimport { body, validationResult } from \'express-validator\';\nimport { PrismaClient } from \'@prisma/client\';\nimport { asyncHandler, createError } from \'../middleware/errorHandler\';\nimport { sendEmail } from \'../utils/email\';\nimport { logger } from \'../utils/logger\';\n\nconst router = express.Router();\nconst prisma = new PrismaClient();\n\n// User Registration\nrouter.post(\'/register\', [\n  body(\'email\').isEmail().normalizeEmail(),\n  body(\'password\').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/),\n  body(\'firstName\').trim().isLength({ min: 2, max: 50 }),\n  body(\'lastName\').trim().isLength({ min: 2, max: 50 }),\n  body(\'phone\').optional().isMobilePhone(\'any\'),\n  body(\'country\').optional().trim().isLength({ min: 2, max: 100 }),\n], asyncHandler(async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    throw createError(\'Validation failed\', 400);\n  }\n\n  const { email, password, firstName, lastName, phone, country } = req.body;\n\n  // Check if user already exists\n  const existingUser = await prisma.user.findUnique({\n    where: { email },\n  });\n\n  if (existingUser) {\n    throw createError(\'User already exists with this email\', 409);\n  }\n\n  // Hash password\n  const hashedPassword = await bcrypt.hash(password, 12);\n\n  // Create user\n  const user = await prisma.user.create({\n    data: {\n      email,\n      password: hashedPassword,\n      firstName,\n      lastName,\n      phone,\n      country,\n    },\n    select: {\n      id: true,\n      email: true,\n      firstName: true,\n      lastName: true,\n      createdAt: true,\n    },\n  });\n\n  // Generate JWT token\n  const token = jwt.sign(\n    { userId: user.id, email: user.email },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'7d\' }\n  );\n\n  // Send welcome email\n  await sendEmail({\n    to: user.email,\n    template: \'welcome\',\n    data: {\n      firstName: user.firstName,\n      email: user.email,\n      dashboardUrl: `${process.env.FRONTEND_URL}/dashboard`,\n      logoUrl: `${process.env.FRONTEND_URL}/assets/brand/bluerock-logo.png`,\n    },\n  });\n\n  logger.info(`New user registered: ${user.email}`);\n\n  res.status(201).json({\n    success: true,\n    message: \'Registration successful\',\n    data: {\n      user,\n      token,\n    },\n  });\n}));\n\n// User Login\nrouter.post(\'/login\', [\n  body(\'email\').isEmail().normalizeEmail(),\n  body(\'password\').notEmpty(),\n], asyncHandler(async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    throw createError(\'Invalid email or password\', 400);\n  }\n\n  const { email, password } = req.body;\n\n  // Find user\n  const user = await prisma.user.findUnique({\n    where: { email },\n  });\n\n  if (!user || !user.isActive) {\n    throw createError(\'Invalid email or password\', 401);\n  }\n\n  // Verify password\n  const isValidPassword = await bcrypt.compare(password, user.password);\n  if (!isValidPassword) {\n    throw createError(\'Invalid email or password\', 401);\n  }\n\n  // Update last login\n  await prisma.user.update({\n    where: { id: user.id },\n    data: { lastLoginAt: new Date() },\n  });\n\n  // Generate JWT token\n  const token = jwt.sign(\n    { userId: user.id, email: user.email },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'7d\' }\n  );\n\n  logger.info(`User logged in: ${user.email}`);\n\n  res.json({\n    success: true,\n    message: \'Login successful\',\n    data: {\n      user: {\n        id: user.id,\n        email: user.email,\n        firstName: user.firstName,\n        lastName: user.lastName,\n        balance: user.balance,\n        totalInvested: user.totalInvested,\n        totalEarnings: user.totalEarnings,\n      },\n      token,\n    },\n  });\n}));\n\n// Admin Login\nrouter.post(\'/admin/login\', [\n  body(\'email\').isEmail().normalizeEmail(),\n  body(\'password\').notEmpty(),\n], asyncHandler(async (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    throw createError(\'Invalid email or password\', 400);\n  }\n\n  const { email, password } = req.body;\n\n  // Find admin user\n  const adminUser = await prisma.adminUser.findUnique({\n    where: { email },\n  });\n\n  if (!adminUser || !adminUser.isActive) {\n    throw createError(\'Invalid email or password\', 401);\n  }\n\n  // Verify password\n  const isValidPassword = await bcrypt.compare(password, adminUser.password);\n  if (!isValidPassword) {\n    throw createError(\'Invalid email or password\', 401);\n  }\n\n  // Update last login\n  await prisma.adminUser.update({\n    where: { id: adminUser.id },\n    data: { lastLoginAt: new Date() },\n  });\n\n  // Generate JWT token\n  const token = jwt.sign(\n    { userId: adminUser.id, email: adminUser.email, role: adminUser.role },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'8h\' }\n  );\n\n  // Log admin login\n  await prisma.auditLog.create({\n    data: {\n      adminUserId: adminUser.id,\n      action: \'LOGIN\',\n      entity: \'AdminUser\',\n      entityId: adminUser.id,\n      ipAddress: req.ip,\n      userAgent: req.get(\'User-Agent\'),\n    },\n  });\n\n  logger.info(`Admin logged in: ${adminUser.email}`);\n\n  res.json({\n    success: true,\n    message: \'Admin login successful\',\n    data: {\n      user: {\n        id: adminUser.id,\n        email: adminUser.email,\n        firstName: adminUser.firstName,\n        lastName: adminUser.lastName,\n        role: adminUser.role,\n      },\n      token,\n    },\n  });\n}));\n\n// Password Reset Request\nrouter.post(\'/forgot-password\', [\n  body(\'email\').isEmail().normalizeEmail(),\n], asyncHandler(async (req, res) => {\n  const { email } = req.body;\n\n  const user = await prisma.user.findUnique({\n    where: { email },\n  });\n\n  // Always return success to prevent email enumeration\n  if (!user) {\n    return res.json({\n      success: true,\n      message: \'If an account with that email exists, a password reset link has been sent.\',\n    });\n  }\n\n  // Generate reset token\n  const resetToken = jwt.sign(\n    { userId: user.id, type: \'password_reset\' },\n    process.env.JWT_SECRET!,\n    { expiresIn: \'1h\' }\n  );\n\n  // Send password reset email\n  await sendEmail({\n    to: user.email,\n    template: \'passwordReset\',\n    data: {\n      firstName: user.firstName,\n      resetUrl: `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`,\n      logoUrl: `${process.env.FRONTEND_URL}/assets/brand/bluerock-logo.png`,\n    },\n  });\n\n  res.json({\n    success: true,\n    message: \'If an account with that email exists, a password reset link has been sent.\',\n  });\n}));\n\n// Password Reset\nrouter.post(\'/reset-password\', [\n  body(\'token\').notEmpty(),\n  body(\'password\').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/),\n], asyncHandler(async (req, res) => {\n  const { token, password } = req.body;\n\n  try {\n    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;\n    \n    if (decoded.type !== \'password_reset\') {\n      throw createError(\'Invalid reset token\', 400);\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 12);\n\n    await prisma.user.update({\n      where: { id: decoded.userId },\n      data: { password: hashedPassword },\n    });\n\n    res.json({\n      success: true,\n      message: \'Password reset successful\',\n    });\n\n  } catch (error) {\n    throw createError(\'Invalid or expired reset token\', 400);\n  }\n}));\n\nexport default router;\n</create-file>\n</function_calls>'}